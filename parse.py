import re
import pages.debug_terminal
import pages.viewport
import pages.code_output
import numpy as np


INSTRUCTIONS = []

OFFSET_X = 0
OFFSET_Y = 0
OFFSET_Z = 0

Z_SKIP_HEIGHT = 25
#global Z_MOVE_HEIGHT
Z_MOVE_HEIGHT = 10
MOVE_SPEED = 1200
IMAGE_POSITION = [50, 50, 100]

CAMERA_X = -20
CAMERA_Y = -20
CAMERA_Z = 0

MAGNET_X = 20
MAGNET_Y = -20
MAGNET_Z = 0

PIPETTE_X = -20
PIPETTE_Y = 20
PIPETTE_Z = 0

global MODE
#MODE = 'N'

INSTRUCTIONS_HEADER =  ("; code generated by Ferrobotics Device Controller\n" + 
                "M84 X Y Z S12000 ; set timeout\n" + 
                "G90 ; use absolute positioning\n" +
                "G21 ; use milimeters\n" +
                "G28W ; autohome\n"
                )

global coord_set, wrong_coord_set 
coord_set = None
wrong_coord_set = None

def instructions_get_prev_g01():
    '''get last g01 instruction'''
    for i in range(1, len(INSTRUCTIONS) + 1):
        if isinstance(INSTRUCTIONS[-i], InstructionG01):
            return INSTRUCTIONS[-i]
    return None  # not found

def instructions_get_prev_g01_from_index(index):
    j = index
    while not isinstance(INSTRUCTIONS[j],InstructionG01) and j > 0: 
        j -= 1
    if j == 0: return (0, 0)
    x = INSTRUCTIONS[j].data["x"]
    y = INSTRUCTIONS[j].data["y"]
    return (x, y)

def set_Z_offset(new_Z):
    global Z_MOVE_HEIGHT
    Z_MOVE_HEIGHT = new_Z
    print("Z height = " + str(Z_MOVE_HEIGHT))
        

class InstructionG01:
    '''contains data for GCode G01 (MOVE) instruction'''

    def __init__(self, pos_x, pos_y, pos_z, f):
        self.data = {"x": pos_x, "y": pos_y, "z": pos_z, "f": f}

    def stringify(self, do_comment=False, do_camera_comment = False):
        '''Returns the instruction in stringified form'''
        
        if MODE == 'N':
            out = ("G01 X" + str(self.data["x"]) +
                " Y" + str(self.data["y"]) + 
                " Z" + str(self.data["z"]) +  
                " F" + str(self.data["f"]))
        
        elif MODE == 'M':
            out = ("G01 X" + str(self.data["x"] + MAGNET_X) +
                " Y" + str(self.data["y"] + MAGNET_Y) + 
                " Z" + str(self.data["z"] + + MAGNET_Z) + 
                " F" + str(self.data["f"]))
        
        elif MODE == 'C':
            out = ("G01 X" + str(self.data["x"] + CAMERA_X) +
                " Y" + str(self.data["y"] + CAMERA_Y) + 
                " Z" + str(self.data["z"] + + CAMERA_Z) + 
                " F" + str(self.data["f"]))
        elif MODE == 'P':
            out = ("G01 X" + str(self.data["x"] + PIPETTE_X) +
                " Y" + str(self.data["y"] + PIPETTE_Y) + 
                " Z" + str(self.data["z"] + + PIPETTE_Z) + 
                " F" + str(self.data["f"]))
            
        if (do_comment and self.data["z"]==Z_MOVE_HEIGHT):
            
            out += ("    ; Move to (" +
                f"{self.data['x'] + OFFSET_X}, " +
                f"{self.data['y'] + OFFSET_Y}, " +               
                f"{self.data['z'] + OFFSET_Z}) " +
                f"at speed {self.data['f']}")
        if (do_comment and self.data["z"]==Z_SKIP_HEIGHT):
            out += ("    ; Skip to (" +
                f"{self.data['x'] + OFFSET_X}, " +
                f"{self.data['y'] + OFFSET_Y}, " +
                f"{self.data['z'] + OFFSET_Z}) " +
                f"at speed {self.data['f']}")
        if (do_camera_comment and self.data["z"]==Z_MOVE_HEIGHT): 
            out += ("    ; Camera Move to (" +
                f"{self.data['x'] + OFFSET_X}, " +
                f"{self.data['y'] + OFFSET_Y}, " +
                f"{self.data['z'] + OFFSET_Z}) " +
                f"at speed {self.data['f']}")
        if (do_camera_comment and self.data["z"]==Z_SKIP_HEIGHT): 
            out += ("    ; Camera Skip to (" +
                f"{self.data['x'] + OFFSET_X}, " +
                f"{self.data['y'] + OFFSET_Y}, " +
                f"{self.data['z'] + OFFSET_Z}) " +
                f"at speed {self.data['f']}")
        return out

    def tableify(self):
        '''Returns the instruction in table form'''
        if (self.data["z"]==Z_MOVE_HEIGHT):
            return ["MOVE (G01)",
                    str(self.data["x"]),
                    str(self.data["y"]),
                    str(self.data["z"]),
                    str(self.data["f"]), ""]
        if (self.data["z"]==Z_SKIP_HEIGHT):
            return ["SKIP (G01)",
                    str(self.data["x"]),
                    str(self.data["y"]),
                    str(self.data["z"]),
                    str(self.data["f"]), ""]

# Please use a InstructionG01 instead of creating a SKIPInstructionG01, it breaks things! :(
# - Chai
    
class InstructionG04:
    '''contains data for GCode G04 (DWELL) instruction'''

    def __init__(self, p):
        self.data = {"p": p}

    def stringify(self, do_comment=False):
        '''Returns the instruction in stringified form'''
        out = "G04 P" + str(self.data["p"])
        if do_comment:
            out += f"    ; Wait {self.data['p']} ms"
        return out

    def tableify(self):
        '''Returns the instruction in table form'''
        return ["WAIT (G04)", "", "", "", "", str(self.data["p"])]

class InstructionG0: 
    '''contains data for GCode G0 (MOVE) instruction'''

    def __init__(self, f, pos_z):
        pos_x = 0
        pos_y = 0
        self.data = {"x": pos_x, "y": pos_y, "z": pos_z, "f": f}

    def stringify(self, do_comment=False):
        out = ("G0 " + "F" + str(self.data["f"]) + " "+ "Z" + str(self.data["z"]))
        if do_comment:
            out += ("    ; Rapid move to (" + "0, " + "0, " +
                f"{self.data['z']}) " +
                f"at speed {self.data['f']}")
        return out

    def tableify(self):
        '''Returns the instruction in table form'''
        return ["RELATIVE MOVE (G0)",
                str(0),
                str(0),
                str(self.data["z"]),
                str(self.data["f"])]

class InstructionG21:
    '''contains data for GCode G21 (enter millimeter mode) instruction'''

    def __init__(self):
        self.data = {}

    def stringify(self, do_comment=False):
        '''Returns the instruction in stringified form'''
        out = "G21"
        if do_comment:
            out += "    ; Enter millimeter mode"
        return out

    def tableify(self):
        '''Returns the instruction in table form'''
        return ["MILLIMETER MODE (G21)"]

class InstructionG91:
    '''contains data for GCode G91 (enter relative movement mode) instruction'''

    def __init__(self):
        self.data = {}

    def stringify(self, do_comment=False):
        out = "G91"
        if do_comment:
            out += "    ; Enter relative movement mode"
        return out

    def tableify(self):
        '''Returns the instruction in table form'''
        return ["RELATIVE MODE (G91)"]

# Loading in existing GCode
def parse_g_code(filename):
    # note: func is idempotent if error occurs
    GCode = open(filename, encoding="utf-8")
    instructions = []
    for line in GCode:
        tokens = line.split(" ")
        if len(tokens) == 0:
            continue
        try:
            if tokens[0] == "G01":
                instructions.append(InstructionG01(
                    pos_x = float(tokens[1][1:]),
                    pos_y = float(tokens[2][1:]),
                    pos_z = float(tokens[3][1:]),
                    f = float(tokens[4][1:]),
                ))
            elif tokens[0] == "G04":
                instructions.append(InstructionG04(
                    p = float(tokens[1][1:]),
                ))
            elif tokens[0] == "G0":
                instructions.append(InstructionG0(        
                    f = float(tokens[4][1:]),            
                    pos_z = float(tokens[3][1:]))
                    )
            elif tokens[0] == "M84" or tokens[0] == ";" or tokens[0] == "G90" or tokens[0] == "G21" or tokens[0] == "G91" or tokens[0] == "G28W" :
                # ignore those, those are part of header
                continue
            else:
                pages.debug_terminal.debug_log(f"PARSE FATAL: Unrecognized code: {tokens[0]}")
                return False
        except Exception as e:
            pages.debug_terminal.debug_log(f"PARSE FATAL: expected token not found")
            pages.debug_terminal.debug_log(f"PARSE FATAL: " + str(e))
            return False # error occured

    global INSTRUCTIONS
    INSTRUCTIONS = instructions
    return True

def add_travel(click_grid):

    instr_x1 = float(click_grid[0])
    instr_y1 = float(click_grid[1])

    prev_g01 = instructions_get_prev_g01()
    
    if (prev_g01 is not None)and(instr_x1 == prev_g01.data["x"] and instr_y1 == prev_g01.data["y"]):
        return
    
    if prev_g01 is not None:
        instr_x0 = prev_g01.data["x"]
        instr_y0 = prev_g01.data["y"]
        instr_z0 = prev_g01.data["z"]       
        INSTRUCTIONS.append(InstructionG01(
            pos_x=instr_x1, pos_y=instr_y1, pos_z=Z_MOVE_HEIGHT, f=int(MOVE_SPEED)))
        pages.viewport.grid.draw_line((instr_x0, instr_y0), (instr_x1,instr_y1), color='blue', width=1)

    if prev_g01 is None:
        instr_x0 = instr_x1
        instr_y0 = instr_y1
        INSTRUCTIONS.append(InstructionG01(
            pos_x=instr_x1, pos_y=instr_y1, pos_z=Z_MOVE_HEIGHT, f=int(MOVE_SPEED)))
        
    pages.viewport.render_vertex(instr_x1, instr_y1)
    pages.code_output.render_code_output()

# Travel is a subroutine that adds a point to the ToolPath arrays with the
# tool floating above the chip, traveling at a faster speed.


def add_skip(click_grid):

    instr_x1 = float(click_grid[0])
    instr_y1 = float(click_grid[1])

    prev_g01 = instructions_get_prev_g01()
    if (prev_g01 is not None)and(instr_x1 == prev_g01.data["x"] and instr_y1 == prev_g01.data["y"]):
        return

    if prev_g01 is not None:
        instr_x0 = prev_g01.data["x"]
        instr_y0 = prev_g01.data["y"]
        instr_z0 = prev_g01.data["z"]       
        INSTRUCTIONS.append(InstructionG01(
            pos_x=instr_x1, pos_y=instr_y1, pos_z=Z_SKIP_HEIGHT, f=int(MOVE_SPEED)))
        pages.viewport.grid.draw_line((instr_x0, instr_y0), (instr_x1,instr_y1), color='cyan', width=1)

    if prev_g01 is None:
        instr_x0 = instr_x1
        instr_y0 = instr_y1
        INSTRUCTIONS.append(InstructionG01(
            pos_x=instr_x1, pos_y=instr_y1, pos_z=Z_SKIP_HEIGHT, f=int(MOVE_SPEED)))


    pages.viewport.render_vertex(instr_x1, instr_y1)
    pages.code_output.render_code_output()

def add_capture(click_grid):
    
    global coord_set, wrong_coord_set
    instr_x1 = float(click_grid[0])
    instr_y1 = float(click_grid[1])
    if instr_x1 < np.min((pages.viewport.max_coordx + CAMERA_X, pages.viewport.max_coordx)) and instr_x1 > OFFSET_X and instr_y1 < np.min((pages.viewport.max_coordy + CAMERA_Y, pages.viewport.max_coordy)) and instr_y1 > OFFSET_Y:

        
        
        

        '''
        prev_g01 = instructions_get_prev_g01()
        if prev_g01 is not None and prev_g01.data['camera'] == True:
            instr_x0 = prev_g01.data["x"] +CAMERA_X
            instr_y0 = prev_g01.data["y"] +CAMERA_Y
            instr_z0 = prev_g01.data["z"]
            if instr_z0 == Z_SKIP_HEIGHT:
                INSTRUCTIONS.append(InstructionG01(
                    pos_x=instr_x0, pos_y=instr_y0, pos_z=Z_MOVE_HEIGHT, f=int(MOVE_SPEED)))
            pages.viewport.grid.draw_line((instr_x0, instr_y0), (instr_x1, instr_y1),color='green', width=1)
        if prev_g01 is not None and prev_g01.data['camera'] == False:
            instr_x0 = prev_g01.data["x"]
            instr_y0 = prev_g01.data["y"]
            instr_z0 = prev_g01.data["z"]
            if instr_z0 == Z_SKIP_HEIGHT:
                INSTRUCTIONS.append(InstructionG01(
                    pos_x=instr_x0, pos_y=instr_y0, pos_z=Z_MOVE_HEIGHT, f=int(MOVE_SPEED)))
            pages.viewport.grid.draw_line((instr_x0, instr_y0), (instr_x1, instr_y1),color='green', width=1)
        if prev_g01 is None:
            instr_x0 = instr_x1 
            instr_y0 = instr_y1 
            coord_set = [[instr_x1, instr_x1]]
        else:
            coord_set.append([instr_x1, instr_x1])
        print(coord_set)
        '''
        prev_g01 = instructions_get_prev_g01()
        if coord_set is None:
            coord_set = [[instr_x1, instr_y1]]
        else:
            coord_set.append([instr_x1, instr_y1])

        print(coord_set)
        #INSTRUCTIONS.append(InstructionG01(
        #    pos_x=instr_x1, pos_y=instr_y1, pos_z=Z_MOVE_HEIGHT, f=int(MOVE_SPEED), capture = True))
        '''
        INSTRUCTIONS.append(InstructionG01(
            pos_x=instr_x1 - CAMERA_X , pos_y=instr_y1 - CAMERA_Y , pos_z=Z_MOVE_HEIGHT, f=int(MOVE_SPEED), capture = True)) #consider camera offset from tip
        '''

        pages.viewport.render_capture(instr_x1, instr_y1)
        pages.code_output.render_camera_output()
    else:
        if wrong_coord_set is None:
            wrong_coord_set = [[instr_x1, instr_y1]]
        else:
            wrong_coord_set.append([instr_x1, instr_y1])

        pages.viewport.render_wrong_capture(instr_x1, instr_y1)
        pages.debug_terminal.debug_log("Point outside camera bounds")
        print("Point outside camera bounds")
    
    
    return coord_set

def add_pull(velocity,distance):
        INSTRUCTIONS.append(InstructionG91())
        INSTRUCTIONS.append(InstructionG0(f=velocity, pos_z= distance))
        pages.debug_terminal.syringe_log(INSTRUCTIONS[-2].stringify())
        pages.debug_terminal.syringe_log(INSTRUCTIONS[-1].stringify())


def add_push(velocity,distance):
        INSTRUCTIONS.append(InstructionG91())
        INSTRUCTIONS.append(InstructionG0(f=velocity, pos_z= -distance))
        pages.debug_terminal.syringe_log(INSTRUCTIONS[-2].stringify())
        pages.debug_terminal.syringe_log(INSTRUCTIONS[-1].stringify())

def move_g01(instr_index, coords):
    INSTRUCTIONS[instr_index].data["x"] = coords[0]
    INSTRUCTIONS[instr_index].data["y"] = coords[1]

def is_valid_coordinate(Text):
    StrLen = len(Text)
    StrCount = 0
    while StrCount < StrLen:
        if Text[StrCount].isnumeric():
            pass
        elif Text[StrCount] == '.':
            pass
        elif Text[StrCount] == '-':
            pass
        else:
            return (False)
        StrCount = StrCount + 1
    return (True)

def set_offset(offsets):
    global OFFSET_X, OFFSET_Y, OFFSET_Z
    OFFSET_X, OFFSET_Y, OFFSET_Z = offsets

def set_magnet_offset(offsets):
    global MAGNET_X, MAGNET_Y, MAGNET_Z
    MAGNET_X, MAGNET_Y, MAGNET_Z = offsets

def set_pipette_offset(offsets):
    global PIPETTE_X, PIPETTE_Y, PIPETTE_Z
    PIPETTE_X, PIPETTE_Y, PIPETTE_Z = offsets

def set_camera_offset(offsets):
    global CAMERA_X, CAMERA_Y, CAMERA_Z
    CAMERA_X, CAMERA_Y, CAMERA_Z = offsets

def create_new_file():
    global INSTRUCTIONS
    INSTRUCTIONS = []
    pages.debug_terminal.debug_log("Opened new file.")

def file_save_as(new_filename):
    if new_filename is None or new_filename == "":
        return False
    try:
        f = open(new_filename, "w")
        f.write(INSTRUCTIONS_HEADER)
        for instr in INSTRUCTIONS:
            if not isinstance(instr, InstructionG0) and not isinstance(instr, InstructionG91):
                f.write(instr.stringify(do_comment=True))
                f.write("\n")
        f.close()
        pages.debug_terminal.debug_log(f"Successfully saved at {new_filename}.")
        return True
    except:
        pages.debug_terminal.debug_log(f"FAILED to write at {new_filename}.")
        return False

def syringe_save_as(new_filename):
    print("12312")
    if new_filename is None or new_filename == "":
        return False
    try:
        f = open(new_filename, "w")
        for instr in INSTRUCTIONS:
            if isinstance(instr, InstructionG0) or isinstance(instr, InstructionG91):
                f.write(instr.stringify(do_comment=True))
                f.write("\n")
        f.close()
        pages.debug_terminal.debug_log(f"Successfully saved syringe command at {new_filename}.")
        return True
    except:
        pages.debug_terminal.debug_log(f"FAILED to write at {new_filename}.")
        return False

def file_open(filename):
    # note: func is idempotent if error occurs
    if filename == "Untitled":
        create_new_file()
        return True
    if parse_g_code(filename):
        pages.debug_terminal.debug_log(f"Opened file {filename} succesfully.")
        return True
    else: 
        pages.debug_terminal.debug_log(f"FAILED to open file {filename}. Aborting.")
        return False

CLICK_THRESHOLD = 2
def anything_near_click(coord):
    global INSTRUCTIONS
    for i, instr in enumerate(INSTRUCTIONS):
        if isinstance(instr, InstructionG01):
            if (abs(instr.data["x"] - coord[0]) < CLICK_THRESHOLD and abs(instr.data["y"] - coord[1]) < CLICK_THRESHOLD):
                return True, i
    return False, -1